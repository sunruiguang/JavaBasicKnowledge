1.stack.isEmpty() and stack.empty()是相同的方法，前者是继承 java.util.Vector的方法，后者是属于stack类本身的方法
2.Arrays.binarySearch() 这个方法是返回所搜索的目标的序号，如果数组中没有这个目标，那么将会返回的值为（目标可以插入的序号值的负数值-1）
3.Java 中只有值传递，没有地址传递，或者可以使用引用类型传递，而且，String类型是final类型，从新赋值的话，会在地址中从新开辟一个空间
4.箭头朝那，就往哪里移动，，<< 左移      >> 右移
5.函数重载的条件：函数名必须相同，函数的参数列表不同。。。与函数的访问权限以及返回类型无关。。。参数位置不同，也可以重载，但无太大意义（不建议）
6.length 是数组的属性，，，.length()是String的方法
7.类是对象的抽象，对象是类的具体化，实例是对象的另一个名称
8.抽象类中不一定含有抽象方法，抽象类可以被继承，但是不能被实例化，可以有构造方法，有抽象方法的必定是抽象类
9.接口不能有构造方法，接口中只能包含抽象方法和常量，一个类可以实现多个接口，类实现接口是必须实现其中的方法，接口可以被继承，也可以被实现
10.一个类只能继承一个父类，一个类可以被多个类继承，子类不能继承父类的构造方法
11.equals。对于一个类来说，如果没有重写Object类中的equals的方法，即比较两个对象的值是否相等，如果比较的是两个对象，对应的值则是他们的地址。
12.局部变量没有被初始化，编译不能通过，初始化后能正常执行
13.原先放在内存中不用的变量，由GC管理器进行管理释放，什么时候进行释放，由GC处理。
14.java中可以存中文，但是char只能表示utf16中的bmp部分字符。\u0000--->\uffff .
	因为只有U+0000 到 U+D7FF 和 U+E000 到U+FFFF能用来表示 一个完整的字符，这些叫做 BMP
	在UTF-16编码中，大于U+10000码位将被编码为一对16比特长的码元，即按4个字节编码，此时char无法表示
15.两个if语句，和if-else语句，后面的在时间上，会优化一半，后面的只需判断一次，前面的要判断两次。
16.new Integer('a') 为了安全，而从jdk1.5移除了但是可以运行编译
17.ArrayList、Vector、LinkedList 三个集合都是List接口的实现类，都是可变长度的集合，元素有序。其中ArrayList和Vector底层
	数据结构为数组，适合做查询查找；LinkedList 底层数据结构为双向链表，适合做元素的增删。ArrayList线程不安全，Vector线程安全
18.final，关键字，被修饰成员变量不可变，finalize，垃圾收集器执行时会调用被回收对象的finalize方法；
	finally，异常处理部分必须被执行的部分；
19.泛型是javaSE1.5的新特性，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。引入泛型的好处是安全简单。
	在javaSE1.5之前，没有泛型的情况下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型
	转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，
	在运行的时候才出现异常，这是一个安全隐患
20.^异或    相同为0，不同为 1
21.list的特有的迭代器ListIterator，可以进行数据的增删改查。

